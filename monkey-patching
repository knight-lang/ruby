#!/usr/bin/env ruby

class Object
  include Comparable
  def coerce(lhs) = [lhs, to_int]
  alias call itself
  def truthy? = !to_ary.empty?
  def to_str = to_s rescue call.to_str
  def to_int = to_i rescue call.to_int
  def to_ary = to_a rescue call.to_ary
end

class String
  alias _old_to_i to_i; def to_i = sub(/0d.+/, '')._old_to_i # get rid of the `0d12` bug
  alias to_ary chars
  alias ascii ord
end

class Array
  def to_str = join(?\n)
  alias to_int length
  def *(r) = cycle(r).to_a
  alias ** join
end


class Integer
  def to_ary = abs.digits.reverse.map { _1 * (self <=> 0) }
  alias truthy? nonzero?
  alias ascii chr
end

class NilClass
  def inspect = 'null'
end

class TrueClass
  def to_int = 1
  def to_ary = [self]
  def >(r) = !r.truthy?
  def <(r) = false
end

class FalseClass
  def to_int = 0
  def to_ary = []
  def >(r) = false
  def <(r) = !!r.truthy?
end

class Fn
  def initialize(val, args) = (@val, @args = val, args)
  def call = @val.(*@args)
  undef to_s
end

$vars = {}
class Symbol
  def call = $vars[self]
  undef to_s
end

FNS = {
  # ARITY 0
  ?P => -> { gets&.sub(/\r*\n?\z/, '') },
  ?R => -> { rand 0..0xffff_ffff },

  # ARITY 1
  ?B => -> { _1 },
  ?C => -> { _1.().() },
  ?Q => -> { exit _1.to_int },
  ?D => -> { print (t = _1.()).inspect; t },
  ?O => -> { print (x = _1.to_str)[-1] == '\\' ? x.chop : x + "\n" },
  ?L => -> { _1.to_ary.length },
  ?! => -> { !_1.truthy? },
  ?~ => -> { -_1.to_int },
  ?A => -> { _1.().ascii },
  ?, => -> { [_1.()] },
  ?[ => -> { _1.()[0] },
  ?] => -> { _1.()[1..] },

  # Arity 2
  ?+ => -> { _1.() + _2.() },
  ?- => -> { _1.() - _2.() },
  ?* => -> { _1.() * (_2.()||0) },
  ?/ => -> { _1.().fdiv(_2.()).truncate },
  ?% => -> { _1.() % _2.() },
  ?^ => -> { _1.() ** _2.() },
  ?? => -> { _1.().eql? _2.() }, # lol this fixes an issue with `0 == '0'` with `to_str` on ints.
  ?< => -> { _1.() < _2.() },
  ?> => -> { _1.() > _2.() },
  ?& => -> { (t = _1.()).truthy? ? _2.() : t },
  ?| => -> { (t = _1.()).truthy? ? t : _2.() },
  ?; => -> { _1.(); _2.() },
  ?= => -> { $vars[_1] = _2.() },
  ?W => -> { _2.() while _1.truthy? },

  # Arity 3
  ?I => -> { (_1.truthy? ? _2 : _3).() },
  ?G => -> { _1.()[_2.()||0, _3.()||0] },

  # Arity 4
  ?S => -> { (d = _1.().dup); d[_2.()||0, _3.()||0] = _4.(); d }, # TODO: eval order is diff bxn ruby versions
}

def parse!
  # Delete leading whitespace
  @src.slice! /\A(?:[\s():]+|\#.*)+/

  # Parse otu the token
  case
  when @src.slice!(/\A\d+/)                           then $&.to_i
  when @src.slice!(/\A[a-z_][\w&&[^[:upper:]]]*/)     then :"#$&"
  when @src.slice!(/\A(?:'([^']*)'|"([^"]*)")/)       then $+
  when @src.slice!(/\A(?:([TF])|N)[A-Z_]*/)           then $1&.then { _1 == 'T' }
  when @src.slice!(/\A@/)                             then []
  when (f=FNS[@src[0]]) && @src.slice!(/\A([A-Z_]+|.)/) then Fn.new f, f.arity.times.map { parse! }
  else raise "unknown token start: #{@src[0].inspect}"
  end
end

@src = $*.shift == '-f' ? File.read($*.shift) : +$*.shift
parse!.()
