#!/usr/bin/env ruby

class Object
  def coerce(lhs) = [lhs, to_int]
  include Comparable
  alias call itself
  alias truthy? itself
  def falsey? = !truthy?
  def to_str = to_s
  def to_int = to_i
  def to_ary = to_a
end

class String
  alias _old_to_i to_i; def to_i = sub(/0d.+/, '')._old_to_i # get rid of the `0d12` bug
  alias to_ary chars
  def truthy? = !empty?
  alias ascii ord
end

class Array
  # TODO: could be fixed
  def *(r) = cycle(r.to_int).to_a # still needed?
  alias to_int length
  def to_str = join("\n")
  alias ** join
  def truthy? = !empty?
end


class Integer
  def to_ary = abs.digits.reverse.map { _1 * (self <=> 0) }
  alias truthy? nonzero?
  alias ascii chr
end

class NilClass
  def inspect = 'null'
end

class TrueClass
  def to_int = 1
  def to_ary = [self]
  def >(r) = !r.truthy?
  def <(r) = false
end

class FalseClass
  def to_int = 0
  def to_ary = []
  def >(r) = false
  def <(r) = !!r.truthy?
end

class Fn
  def initialize(val, args) = (@val, @args = val, args)
  def call = @val.(*@args)
  def to_int = call.to_int
  def to_str = call.to_str
  def to_ary = call.to_ary
  def truthy? = call.truthy?
end

$vars = {}
class Symbol
  def call = $vars[self]
  def truthy? = call.truthy?
  def to_int = call.to_int
  def to_str = call.to_str
  def to_ary = call.to_ary
end

FNS = {
  # ARITY 0
  ?P => -> { gets(chomp: true)&.sub(/\r+\z/, '') },
  ?R => -> { rand 0..0xffff_ffff },

  # ARITY 1
  ?B => -> { _1 },
  ?C => -> { _1.().() },
  ?Q => -> { exit _1.to_int },
  ?D => -> { _1.().tap{|x| $> << x.inspect} },
  ?O => -> { (s = _1.to_str).end_with?('\\') ? print(s.chop) : print(s, "\n") },
  ?L => -> { _1.to_ary.length },
  ?! => -> { !_1.truthy? },
  ?~ => -> { -_1.to_int },
  ?A => -> { _1.().ascii },
  ?, => -> { [_1.()] },
  ?[ => -> { _1.()[0] },
  ?] => -> { _1.()[1..] },

  # Arity 2
  ?+ => -> { _1.() + _2.() },
  ?- => -> { _1.() - _2.() },
  ?* => -> { _1.() * (_2.()||0) },
  ?/ => -> { _1.().fdiv(_2.()).truncate },
  ?% => -> { _1.() % _2.() },
  ?^ => -> { _1.() ** _2.() },
  ?? => -> { _1.().eql? _2.() }, # lol does this fix it
  ?< => -> { _1.() < _2.() },
  ?> => -> { _1.() > _2.() },
  ?& => -> { (t = _1.()).truthy? ? _2.() : t },
  ?| => -> { (t = _1.()).truthy? ? t : _2.() },
  ?; => -> { _1.(); _2.() },
  ?= => -> { $vars[_1] = _2.() },
  ?W => -> { _2.() while _1.truthy? },

  # Arity 3
  ?I => -> { (_1.truthy? ? _2 : _3).() },
  ?G => -> { _1.()[_2.()||0, _3.()||0] },

  # Arity 4
  ?S => -> { (d = _1.().dup); d[_2.()||0, _3.()||0] = _4.(); d }, # TODO: eval order is diff bxn ruby versions
}

def parse!(source)
  # Delete leading whitespace
  source.slice! /\A(?:[\s():]+|\#.*)+/

  case
  when source.slice!(/\A\d+/) then $&.to_i
  when source.slice!(/\A[a-z_][\w&&[^[:upper:]]]*/) then :"#$&"
  when source.slice!(/\A(?:'([^']*)'|"([^"]*)")/) then $+
  when source.slice!(/\A(?:([TF])|N)[A-Z_]*/) then $1&.then { _1 == 'T' }
  when source.slice!(/\A@/) then []
  when source.slice!(/\A(([A-Z])[A-Z_]*|.)/)
    f = FNS[$+] or abort "unknown token start: #{$+.inspect}"
    Fn.new(f, f.arity.times.map { parse! source })
  else raise "unknown token start: #{source[0].inspect}"
  end
end

parse!($*.shift == '-f' ? File.read($*.shift) : +$*.shift).()
